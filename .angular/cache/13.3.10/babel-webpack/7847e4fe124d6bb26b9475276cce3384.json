{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nvar MAX_REDIRECTS = 100;\n/** @private */\n\nvar HttpConnection =\n/** @class */\nfunction () {\n  function HttpConnection(url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.stopPromiseResolver = function () {};\n\n    this.features = {};\n    this.negotiateVersion = 1;\n    Arg.isRequired(url, \"url\");\n    this.logger = createLogger(options.logger);\n    this.baseUrl = this.resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n\n    var webSocketModule = null;\n    var eventSourceModule = null;\n\n    if (Platform.isNode && typeof require !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n\n    if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (Platform.isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n\n    if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (Platform.isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n\n    this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n    this.connectionStarted = false;\n    this.options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  HttpConnection.prototype.start = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var message, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            transferFormat = transferFormat || TransferFormat.Binary;\n            Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n            this.logger.log(LogLevel.Debug, \"Starting connection with transfer format '\" + TransferFormat[transferFormat] + \"'.\");\n\n            if (this.connectionState !== \"Disconnected\"\n            /* Disconnected */\n            ) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\n            }\n\n            this.connectionState = \"Connecting\"\n            /* Connecting */\n            ;\n            this.startInternalPromise = this.startInternal(transferFormat);\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 1:\n            _a.sent();\n\n            if (!(this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            )) return [3\n            /*break*/\n            , 3];\n            message = \"Failed to start the HttpConnection before stop() was called.\";\n            this.logger.log(LogLevel.Error, message); // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            _a.sent();\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(message))];\n\n          case 3:\n            if (this.connectionState !== \"Connected\"\n            /* Connected */\n            ) {\n              message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n              this.logger.log(LogLevel.Error, message);\n              return [2\n              /*return*/\n              , Promise.reject(new Error(message))];\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.connectionStarted = true;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.send = function (data) {\n    if (this.connectionState !== \"Connected\"\n    /* Connected */\n    ) {\n      return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n    }\n\n    if (!this.sendQueue) {\n      this.sendQueue = new TransportSendQueue(this.transport);\n    } // Transport will not be null if state is connected\n\n\n    return this.sendQueue.send(data);\n  };\n\n  HttpConnection.prototype.stop = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState === \"Disconnected\"\n            /* Disconnected */\n            ) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            if (this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            ) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n              return [2\n              /*return*/\n              , this.stopPromise];\n            }\n\n            this.connectionState = \"Disconnecting\"\n            /* Disconnecting */\n            ;\n            this.stopPromise = new Promise(function (resolve) {\n              // Don't complete stop() until stopConnection() completes.\n              _this.stopPromiseResolver = resolve;\n            }); // stopInternal should never throw so just observe it.\n\n            return [4\n            /*yield*/\n            , this.stopInternal(error)];\n\n          case 1:\n            // stopInternal should never throw so just observe it.\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.stopInternal = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Set error as soon as possible otherwise there is a race between\n            // the transport closing and providing an error and the error from a close message\n            // We would prefer the close message error.\n            this.stopError = error;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (!this.transport) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.transport.stop()];\n\n          case 6:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"HttpConnection.transport.stop() threw error '\" + e_2 + \"'.\");\n            this.stopConnection();\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            this.transport = undefined;\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            _a.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.startInternal = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, negotiateResponse, redirects, _loop_1, this_1, e_3;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.baseUrl;\n            this.accessTokenFactory = this.options.accessTokenFactory;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 12,, 13]);\n\n            if (!this.options.skipNegotiation) return [3\n            /*break*/\n            , 5];\n            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3\n            /*break*/\n            , 3]; // No need to add a connection ID in this case\n\n            this.transport = this.constructTransport(HttpTransportType.WebSockets); // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n\n            return [4\n            /*yield*/\n            , this.startTransport(url, transferFormat)];\n\n          case 2:\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n\n          case 4:\n            return [3\n            /*break*/\n            , 11];\n\n          case 5:\n            negotiateResponse = null;\n            redirects = 0;\n\n            _loop_1 = function _loop_1() {\n              var accessToken_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this_1.getNegotiationResponse(url)];\n\n                  case 1:\n                    negotiateResponse = _a.sent(); // the user tries to stop the connection when it is being started\n\n                    if (this_1.connectionState === \"Disconnecting\"\n                    /* Disconnecting */\n                    || this_1.connectionState === \"Disconnected\"\n                    /* Disconnected */\n                    ) {\n                      throw new Error(\"The connection was stopped during negotiation.\");\n                    }\n\n                    if (negotiateResponse.error) {\n                      throw new Error(negotiateResponse.error);\n                    }\n\n                    if (negotiateResponse.ProtocolVersion) {\n                      throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n\n                    if (negotiateResponse.url) {\n                      url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                      accessToken_1 = negotiateResponse.accessToken;\n\n                      this_1.accessTokenFactory = function () {\n                        return accessToken_1;\n                      };\n                    }\n\n                    redirects++;\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 6;\n\n          case 6:\n            return [5\n            /*yield**/\n            , _loop_1()];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3\n            /*break*/\n            , 6];\n            _a.label = 9;\n\n          case 9:\n            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n              throw new Error(\"Negotiate redirection limit exceeded.\");\n            }\n\n            return [4\n            /*yield*/\n            , this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\n\n          case 10:\n            _a.sent();\n\n            _a.label = 11;\n\n          case 11:\n            if (this.transport instanceof LongPollingTransport) {\n              this.features.inherentKeepAlive = true;\n            }\n\n            if (this.connectionState === \"Connecting\"\n            /* Connecting */\n            ) {\n              // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n              // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n              this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n              this.connectionState = \"Connected\"\n              /* Connected */\n              ;\n            }\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            e_3 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e_3);\n            this.connectionState = \"Disconnected\"\n            /* Disconnected */\n            ;\n            this.transport = undefined; // if start fails, any active calls to stop assume that start will complete the stop promise\n\n            this.stopPromiseResolver();\n            return [2\n            /*return*/\n            , Promise.reject(e_3)];\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.getNegotiationResponse = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, token, _a, name, value, negotiateUrl, response, negotiateResponse, e_4;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            headers = {};\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _b.sent();\n\n            if (token) {\n              headers[\"Authorization\"] = \"Bearer \" + token;\n            }\n\n            _b.label = 2;\n\n          case 2:\n            _a = getUserAgentHeader(), name = _a[0], value = _a[1];\n            headers[name] = value;\n            negotiateUrl = this.resolveNegotiateUrl(url);\n            this.logger.log(LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\n            _b.label = 3;\n\n          case 3:\n            _b.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.httpClient.post(negotiateUrl, {\n              content: \"\",\n              headers: __assign({}, headers, this.options.headers),\n              withCredentials: this.options.withCredentials\n            })];\n\n          case 4:\n            response = _b.sent();\n\n            if (response.statusCode !== 200) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unexpected status code returned from negotiate '\" + response.statusCode + \"'\"))];\n            }\n\n            negotiateResponse = JSON.parse(response.content);\n\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n              // Negotiate version 0 doesn't use connectionToken\n              // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n              negotiateResponse.connectionToken = negotiateResponse.connectionId;\n            }\n\n            return [2\n            /*return*/\n            , negotiateResponse];\n\n          case 5:\n            e_4 = _b.sent();\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_4);\n            return [2\n            /*return*/\n            , Promise.reject(e_4)];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionToken);\n  };\n\n  HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\n            if (!this.isITransport(requestedTransport)) return [3\n            /*break*/\n            , 2];\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 1:\n            _a.sent();\n\n            this.connectionId = negotiateResponse.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 2:\n            transportExceptions = [];\n            transports = negotiateResponse.availableTransports || [];\n            negotiate = negotiateResponse;\n            _i = 0, transports_1 = transports;\n            _a.label = 3;\n\n          case 3:\n            if (!(_i < transports_1.length)) return [3\n            /*break*/\n            , 13];\n            endpoint = transports_1[_i];\n            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n            if (!(transportOrError instanceof Error)) return [3\n            /*break*/\n            , 4]; // Store the error and continue, we don't want to cause a re-negotiate in these cases\n\n            transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\n            return [3\n            /*break*/\n            , 12];\n\n          case 4:\n            if (!this.isITransport(transportOrError)) return [3\n            /*break*/\n            , 12];\n            this.transport = transportOrError;\n            if (!!negotiate) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.getNegotiationResponse(url)];\n\n          case 6:\n            negotiate = _a.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            ex_1 = _a.sent();\n            return [2\n            /*return*/\n            , Promise.reject(ex_1)];\n\n          case 8:\n            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 10:\n            _a.sent();\n\n            this.connectionId = negotiate.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 11:\n            ex_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\n            negotiate = undefined;\n            transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\n\n            if (this.connectionState !== \"Connecting\"\n            /* Connecting */\n            ) {\n              message = \"Failed to select transport before stop() was called.\";\n              this.logger.log(LogLevel.Debug, message);\n              return [2\n              /*return*/\n              , Promise.reject(new Error(message))];\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            _i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 13:\n            if (transportExceptions.length > 0) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\n            }\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.constructTransport = function (transport) {\n    switch (transport) {\n      case HttpTransportType.WebSockets:\n        if (!this.options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n\n        return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\n\n      case HttpTransportType.ServerSentEvents:\n        if (!this.options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n\n        return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials, this.options.headers || {});\n\n      case HttpTransportType.LongPolling:\n        return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials, this.options.headers || {});\n\n      default:\n        throw new Error(\"Unknown transport: \" + transport + \".\");\n    }\n  };\n\n  HttpConnection.prototype.startTransport = function (url, transferFormat) {\n    var _this = this;\n\n    this.transport.onreceive = this.onreceive;\n\n    this.transport.onclose = function (e) {\n      return _this.stopConnection(e);\n    };\n\n    return this.transport.connect(url, transferFormat);\n  };\n\n  HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = HttpTransportType[endpoint.transport];\n\n    if (transport === null || transport === undefined) {\n      this.logger.log(LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n      return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        var transferFormats = endpoint.transferFormats.map(function (s) {\n          return TransferFormat[s];\n        });\n\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === HttpTransportType.WebSockets && !this.options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this.options.EventSource) {\n            this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\n            return new Error(\"'\" + HttpTransportType[transport] + \"' is not supported in your environment.\");\n          } else {\n            this.logger.log(LogLevel.Debug, \"Selecting transport '\" + HttpTransportType[transport] + \"'.\");\n\n            try {\n              return this.constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + TransferFormat[requestedTransferFormat] + \"'.\");\n          return new Error(\"'\" + HttpTransportType[transport] + \"' does not support \" + TransferFormat[requestedTransferFormat] + \".\");\n        }\n      } else {\n        this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it was disabled by the client.\");\n        return new Error(\"'\" + HttpTransportType[transport] + \"' is disabled by the client.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.isITransport = function (transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  };\n\n  HttpConnection.prototype.stopConnection = function (error) {\n    var _this = this;\n\n    this.logger.log(LogLevel.Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\n    this.transport = undefined; // If we have a stopError, it takes precedence over the error from the transport\n\n    error = this.stopError || error;\n    this.stopError = undefined;\n\n    if (this.connectionState === \"Disconnected\"\n    /* Disconnected */\n    ) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\n      return;\n    }\n\n    if (this.connectionState === \"Connecting\"\n    /* Connecting */\n    ) {\n      this.logger.log(LogLevel.Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is still in the connecting state.\");\n      throw new Error(\"HttpConnection.stopConnection(\" + error + \") was called while the connection is still in the connecting state.\");\n    }\n\n    if (this.connectionState === \"Disconnecting\"\n    /* Disconnecting */\n    ) {\n      // A call to stop() induced this call to stopConnection and needs to be completed.\n      // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n      this.stopPromiseResolver();\n    }\n\n    if (error) {\n      this.logger.log(LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\n    } else {\n      this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n    }\n\n    if (this.sendQueue) {\n      this.sendQueue.stop().catch(function (e) {\n        _this.logger.log(LogLevel.Error, \"TransportSendQueue.stop() threw error '\" + e + \"'.\");\n      });\n      this.sendQueue = undefined;\n    }\n\n    this.connectionId = undefined;\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n\n    if (this.connectionStarted) {\n      this.connectionStarted = false;\n\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.resolveUrl = function (url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n\n    if (!Platform.isBrowser || !window.document) {\n      throw new Error(\"Cannot resolve '\" + url + \"'.\");\n    } // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n\n\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this.logger.log(LogLevel.Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\n    return aTag.href;\n  };\n\n  HttpConnection.prototype.resolveNegotiateUrl = function (url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\n    }\n\n    return negotiateUrl;\n  };\n\n  return HttpConnection;\n}();\n\nexport { HttpConnection };\n\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\n\n\nvar TransportSendQueue =\n/** @class */\nfunction () {\n  function TransportSendQueue(transport) {\n    this.transport = transport;\n    this.buffer = [];\n    this.executing = true;\n    this.sendBufferedData = new PromiseSource();\n    this.transportResult = new PromiseSource();\n    this.sendLoopPromise = this.sendLoop();\n  }\n\n  TransportSendQueue.prototype.send = function (data) {\n    this.bufferData(data);\n\n    if (!this.transportResult) {\n      this.transportResult = new PromiseSource();\n    }\n\n    return this.transportResult.promise;\n  };\n\n  TransportSendQueue.prototype.stop = function () {\n    this.executing = false;\n    this.sendBufferedData.resolve();\n    return this.sendLoopPromise;\n  };\n\n  TransportSendQueue.prototype.bufferData = function (data) {\n    if (this.buffer.length && typeof this.buffer[0] !== typeof data) {\n      throw new Error(\"Expected data to be of type \" + typeof this.buffer + \" but was of type \" + typeof data);\n    }\n\n    this.buffer.push(data);\n    this.sendBufferedData.resolve();\n  };\n\n  TransportSendQueue.prototype.sendLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var transportResult, data, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!true) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.sendBufferedData.promise];\n\n          case 1:\n            _a.sent();\n\n            if (!this.executing) {\n              if (this.transportResult) {\n                this.transportResult.reject(\"Connection stopped.\");\n              }\n\n              return [3\n              /*break*/\n              , 6];\n            }\n\n            this.sendBufferedData = new PromiseSource();\n            transportResult = this.transportResult;\n            this.transportResult = undefined;\n            data = typeof this.buffer[0] === \"string\" ? this.buffer.join(\"\") : TransportSendQueue.concatBuffers(this.buffer);\n            this.buffer.length = 0;\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.transport.send(data)];\n\n          case 3:\n            _a.sent();\n\n            transportResult.resolve();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            error_1 = _a.sent();\n            transportResult.reject(error_1);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [3\n            /*break*/\n            , 0];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  TransportSendQueue.concatBuffers = function (arrayBuffers) {\n    var totalLength = arrayBuffers.map(function (b) {\n      return b.byteLength;\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n    var result = new Uint8Array(totalLength);\n    var offset = 0;\n\n    for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\n      var item = arrayBuffers_1[_i];\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n\n    return result.buffer;\n  };\n\n  return TransportSendQueue;\n}();\n\nexport { TransportSendQueue };\n\nvar PromiseSource =\n/** @class */\nfunction () {\n  function PromiseSource() {\n    var _this = this;\n\n    this.promise = new Promise(function (resolve, reject) {\n      var _a;\n\n      return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\n    });\n  }\n\n  PromiseSource.prototype.resolve = function () {\n    this.resolver();\n  };\n\n  PromiseSource.prototype.reject = function (reason) {\n    this.rejecter(reason);\n  };\n\n  return PromiseSource;\n}(); //# sourceMappingURL=HttpConnection.js.map","map":null,"metadata":{},"sourceType":"module"}