{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\dsalgado.contr\\\\source\\\\Workspaces\\\\CAIU-LIBRARY\\\\CAIU-LIBRARY\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\dsalgado.contr\\\\source\\\\Workspaces\\\\CAIU-LIBRARY\\\\CAIU-LIBRARY\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { HttpClient, HttpHeaders } from \"@angular/common/http\";\nimport { Observable, of, throwError } from \"rxjs\";\nimport { catchError, debounceTime, distinctUntilChanged, finalize, map } from \"rxjs/operators\";\nimport { HttpActions } from \"./http.actions\";\nimport { HttpOptions } from \"./http.models\";\nimport { QueryModel } from \"../shared/models\";\nimport { serialize } from \"../shared/utils\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"rxjs\";\nexport var HttpService = /*#__PURE__*/(function () {\n  var HttpService = /*#__PURE__*/function () {\n    function HttpService(http, baseUrl$, authToken$) {\n      var _this = this;\n\n      _classCallCheck(this, HttpService);\n\n      this.http = http;\n      this.baseUrl$ = baseUrl$;\n      this.authToken$ = authToken$;\n      this._authToken = \"\";\n      this._baseUrl = \"\";\n      this.headers = {};\n      this.logEvents = false;\n      this.useDefaultHeaders = true;\n      this.authTokenChanges = this.authToken$.subscribe(function (x) {\n        _this.authToken = x;\n      });\n      this.baseUrlChanges = this.baseUrl$.subscribe(function (x) {\n        _this.baseUrl = x;\n      });\n    }\n\n    _createClass(HttpService, [{\n      key: \"authToken\",\n      get: function get() {\n        return this._authToken;\n      },\n      set: function set(value) {\n        this._authToken = value;\n      }\n    }, {\n      key: \"baseUrl\",\n      get: function get() {\n        return this._baseUrl;\n      },\n      set: function set(value) {\n        this._baseUrl = value;\n      }\n    }, {\n      key: \"defaultHeaders\",\n      get: function get() {\n        var headers = new HttpHeaders();\n        headers = headers.append(\"Content-type\", \"application/json\");\n\n        if (this.authToken) {\n          headers = headers.append(\"Authorization\", \"Bearer \" + this.authToken);\n        }\n\n        return headers;\n      }\n    }, {\n      key: \"requestHeaders\",\n      get: function get() {\n        var _this2 = this;\n\n        var headers = this.useDefaultHeaders ? this.defaultHeaders : new HttpHeaders();\n        Object.keys(this.headers).forEach(function (key) {\n          headers = headers.append(key, _this2.headers[key]);\n        });\n        return headers;\n      }\n    }, {\n      key: \"appendHeaders\",\n      value: function appendHeaders() {\n        var _this3 = this;\n\n        var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var requestHeaders = this.requestHeaders;\n        Object.keys(headers).forEach(function (key) {\n          requestHeaders = requestHeaders.append(key, _this3.headers[key]);\n        });\n        return requestHeaders;\n      }\n      /**\r\n       * Make a DELETE request.\r\n       * @param relativePath\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"delete\",\n      value: function _delete(relativePath) {\n        var _this4 = this;\n\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpOptions();\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = this.appendHeaders(headers);\n        var obs = this.http.delete(url, {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), catchError(function (err) {\n          return _this4.onError(err.error);\n        }), finalize(function () {\n          _this4.onComplete(\"DELETE\", url);\n        }));\n      }\n      /**\r\n       * Make a GET request.\r\n       * @param relativePath\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(relativePath) {\n        var _this5 = this;\n\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpOptions();\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = this.appendHeaders(headers);\n        var obs = this.http.get(url, {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), catchError(function (err) {\n          return _this5.onError(err ? err.error : err);\n        }), finalize(function () {\n          _this5.onComplete(\"GET\", url);\n        }));\n      }\n      /**\r\n       * Make a GET request.\r\n       * @param relativePath\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"getValue\",\n      value: function getValue(relativePath) {\n        var url = this.formatUrl(relativePath);\n        var headers = new HttpHeaders();\n        headers = headers.append(\"Content-type\", \"text/plain\");\n\n        if (this.authToken) {\n          headers = headers.append(\"Authorization\", \"Bearer \" + this.authToken);\n        }\n\n        var obs = this.http.get(url, {\n          headers: headers\n        });\n        return obs;\n      }\n      /**\r\n       * Make a GET request.\r\n       * @param fullPath\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"getFullPath\",\n      value: function getFullPath(fullPath) {\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpOptions();\n        return this.get(fullPath, headers, Object.assign({}, options, {\n          prependBaseUrl: false\n        }));\n      }\n      /**\r\n       * Make an autocomplete GET request.\r\n       * @param relativePath\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"autocomplete\",\n      value: function autocomplete(relativePath, query) {\n        var _this6 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new HttpOptions();\n\n        if (!query.term || query.term.length < 1) {\n          return of([]);\n        }\n\n        var path = \"\".concat(relativePath, \"/\").concat(QueryModel.BuildQueryString(query));\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = this.appendHeaders(headers);\n        var obs = this.http.get(url, {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), debounceTime(500), distinctUntilChanged(), map(function (json) {\n          return HttpActions.matchPath(path, json);\n        }), catchError(function (err) {\n          return _this6.onError(err ? err.error : err);\n        }), finalize(function () {\n          _this6.onComplete(\"GET\", url);\n        }));\n      }\n      /**\r\n       * Make a POST request.\r\n       * @param relativePath\r\n       * @param body\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"post\",\n      value: function post(relativePath, body) {\n        var _this7 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new HttpOptions();\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = this.appendHeaders(headers);\n        var obs = this.http.post(url, serialize(body), {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), catchError(function (err) {\n          return _this7.onError(err ? err.error : err);\n        }), finalize(function () {\n          _this7.onComplete(\"POST\", url);\n        }));\n      }\n      /**\r\n       * Make a POST request with form url-encoded content type.\r\n       * @param relativePath\r\n       * @param body\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"postFormUrlEncoded\",\n      value: function postFormUrlEncoded(relativePath, body) {\n        var _this8 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new HttpOptions();\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = new HttpHeaders({\n          \"content-type\": \"application/x-www-form-urlencoded\"\n        });\n        var obs = this.http.post(url, body, {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), catchError(function (err) {\n          return _this8.onError(err);\n        }), finalize(function () {\n          _this8.onComplete(\"POST FORM URL-ENCODED\", url);\n        }));\n      }\n      /**\r\n       * Make a PUT request.\r\n       * @param relativePath\r\n       * @param body\r\n       * @param headers\r\n       * @param options\r\n       */\n\n    }, {\n      key: \"put\",\n      value: function put(relativePath, body) {\n        var _this9 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new HttpOptions();\n        var url = options.prependBaseUrl ? this.formatUrl(relativePath) : relativePath;\n        var httpHeaders = this.appendHeaders(headers);\n        var obs = this.http.put(url, serialize(body), {\n          headers: httpHeaders\n        });\n        return obs.pipe(map(function (res) {\n          return res && res[\"json\"] && typeof res[\"json\"] === \"function\" ? res[\"json\"]() : res;\n        }), catchError(function (err) {\n          return _this9.onError(err ? err.error : err);\n        }), finalize(function () {\n          _this9.onComplete(\"PUT\", url);\n        }));\n      }\n      /**\r\n       * This method will be used to format URLs for all cross-origin requests.\r\n       */\n\n    }, {\n      key: \"formatUrl\",\n      value: function formatUrl(path) {\n        return \"\".concat(this.baseUrl, \"/\").concat(path);\n      }\n      /**\r\n       * Use this method when a promise is preferred over an observable.\r\n       */\n\n    }, {\n      key: \"getPromise\",\n      value: function getPromise(url) {\n        return this.get(url).toPromise().then(function (res) {\n          return res.json();\n        });\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(error) {\n        console.log(error); // let errorBody: any;\n        // try {\n        //   errorBody = error._body\n        //     ? JSON.parse(error._body)\n        //     : { message: 'Internal server error', statusCode: error.status };\n        // } catch (e) {\n        //   if (error.status <= 0) {\n        //     errorBody = { message: 'Internal server error.', statusCode: 500 };\n        //   }\n        // }\n        // if (errorBody.message) {\n        //   errorBody.message = errorBody.message.replace(\n        //     'An error has occured in the api.System.Exception: ',\n        //     ''\n        //   );\n        //   errorBody.message = errorBody.message.substring(\n        //     0,\n        //     errorBody.message.indexOf(' at')\n        //   );\n        // }\n\n        return throwError({\n          message: error && error.Message ? error.Message : \"An error occurred in the API.\",\n          statusCode: error && error.Code ? error.Code : null\n        });\n      }\n    }, {\n      key: \"onComplete\",\n      value: function onComplete(method, url) {\n        if (this.logEvents) {\n          console.log(\"Completed \".concat(method, \" request to \").concat(url));\n        }\n      }\n    }]);\n\n    return HttpService;\n  }();\n\n  HttpService.ɵfac = function HttpService_Factory(t) {\n    return new (t || HttpService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Observable), i0.ɵɵinject(i2.Observable));\n  };\n\n  HttpService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: HttpService,\n    factory: HttpService.ɵfac,\n    providedIn: \"root\"\n  });\n  return HttpService;\n})();","map":null,"metadata":{},"sourceType":"module"}